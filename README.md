# whisper-transcribe-api-1c
Сервис на FastAPI для асинхронной расшифровки аудиофайлов с использованием faster-whisper.

- Простой менеджер очереди и фонового воркера
- Эндпоинты для загрузки файла, создания задачи, получения статуса и экспорта результатов
- Веб‑интерфейс (UI) на корневом маршруте `/` с DnD‑загрузкой, выбором из ранее загруженных, прогрессом/ETA и экспортом TXT/SRT/JSON
- Управление настройками распознавания через API и UI (сброс модели на лету)
- Результаты с таймкодами фраз (start/end/text)

## Требования

- Windows
- Python 3.11. Python 3.13 пока не поддерживается частью зависимостей (могут пытаться собираться из исходников на Rust).
- Установленный FFmpeg (нужен для большинства аудиоформатов)
- Для GPU: рекомендуется CUDA Toolkit 12.x (например, 12.4) и cuDNN 9. CUDA 13.x не совместима с текущими сборками faster-whisper/ctranslate2, т.к. требуются библиотеки вида `cublas64_12.dll`.
- По умолчанию используется CPU; при наличии CUDA можно включить GPU

## Установка

1. Скачайте и установите FFmpeg:
   - Проверьте: "ffmpeg -version" в PowerShell. Если команда не найдена — установите FFmpeg и добавьте в PATH.
2. Установите Python 3.11 (https://www.python.org/downloads/). Во время установки отметьте «Add Python to PATH».
3. Создайте и активируйте виртуальное окружение на 3.11. Зайти в директорию скрипта:   
```powershell
   py -3.11 -m venv .venv
   .\.venv\Scripts\activate
   ```
4. Установите зависимости:
   ```powershell
   pip install -r requirements.txt
   ```
   Если ранее пробовали с другой версией Python и получили ошибки сборки, очистите кэш: `pip cache purge` и повторите установку в активированном окружении 3.11.

## Запуск

```powershell
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

- Откройте UI: http://localhost:8000/
- Документация Swagger: http://localhost:8000/docs
- Healthcheck: http://localhost:8000/health

### Зачем нужен /health
- Быстрая проверка «жив ли сервис» (liveness) и «готов ли к работе» (readiness)
- Удобно для мониторинга, балансировщиков и первичной диагностики

## Веб‑интерфейс (UI)

- Загрузка файла перетаскиванием или кнопкой, с прогресс‑баром.
- Выбор из ранее загруженных файлов: список подгружается из `/api/v1/uploads`.
- Создание задачи и автоматический опрос статуса.
- Прогресс и ETA (если доступны) отображаются на панели статуса.
- __Отображение результата__: после `COMPLETED` UI показывает таблицу фраз и сводный текст, основанные на `results.phrases`.
- Экспорт результата: ссылки на TXT/SRT/JSON появляются после завершения.
- Переключение темы (светлая/тёмная), хранение выбора в LocalStorage.
- Управление настройками распознавания (через UI → `/api/v1/settings`), «хард‑ресет» (`/api/v1/reset`) для очистки очереди и переинициализации модели.
- Список задач: раздел «5) Список задач» отображает все задачи, их статус/прогресс/ETA и даёт ссылки экспорта.

Шаги работы через UI:
1) Загрузите файл или выберите из списка «загруженных».
2) Нажмите «Создать задачу» — получите `task_id`.
3) Нажмите «Проверять статус» — дождитесь `COMPLETED` и скачайте экспорт.

## Настройки устройства и качество (CPU/GPU)

Сервис использует faster‑whisper (`faster_whisper.WhisperModel`) и допускает выбор модели и типа вычислений. Ключевые переменные (см. `app/config.py`):

- __WHISPER_DEVICE__: `auto|cuda|cpu` (по умолчанию `auto`). При `auto` выполняется попытка CUDA с фолбэком на CPU.
- __WHISPER_MODEL__: имя модели Whisper, например `tiny|base|small|medium|large-v3` (и другие, поддерживаемые faster‑whisper/ctranslate2).
- __WHISPER_COMPUTE_TYPE__: `int8|int8_float16|float16|float32|...`
  - По умолчанию: для CUDA — `float16`, для CPU — `int8`.
- __WHISPER_LANGUAGE__: ISO-код языка (например, `ru`), пусто ⇒ автоопределение.
- __WHISPER_TASK__: `transcribe` (распознавание) или `translate` (перевод на английский).
- __WHISPER_BEAM__: ширина бим‑поиска (целое, по умолчанию 8).
- __WHISPER_PATIENCE__: параметр поиска (по умолчанию 1.0).
- __WHISPER_LENGTH_PENALTY__: штраф за длину (по умолчанию 1.0).
- __WHISPER_CONDITION_PREV__: учитывать предыдущий текст: `true|false` (по умолчанию `false`).
- __WHISPER_VAD_MIN_SIL_MS__: минимальная тишина для VAD, мс (по умолчанию 300).
- __WHISPER_PROMPT__: начальная подсказка (стиль/лексика, необязательно).

## API (кратко)

- GET `/api/v1/uploads` → `{ files: [ { name, path, size }, ... ] }`
- POST `/api/v1/upload` (multipart/form-data, поле `file`) → `{ stored_path }`
- POST `/api/v1/create_task` (`{ file_path }`) → `{ task_id, status: "PENDING", queue_position }`
- GET `/api/v1/status/{task_id}` → статус задачи.
  - Для `IN_PROGRESS` возможны поля `progress` (0..1) и `eta_seconds`.
  - Для `COMPLETED`: `results: { phrases: [ { start, end, text }, ... ] }` (см. `app/schemas.py`).
- GET `/api/v1/tasks` → список задач (без результатов).
- GET `/api/v1/tasks/{task_id}` → подробности задачи (включая `results` при готовности).
- GET `/export/{task_id}.{fmt}` где `{fmt} = txt|srt|json` → экспорт результата.
- GET `/api/v1/settings` / POST `/api/v1/settings` → чтение/применение настроек в рантайме с переинициализацией модели.
- POST `/api/v1/reset` → очистка очереди и сброс модели.

### WebSocket: live‑статус

Доступен потоковый статус без периодического опроса:

- WS `/ws/status/{task_id}`
  - Для `PENDING`: присылается `queue_position`.
  - Для `IN_PROGRESS`: присылаются `progress` и `eta_seconds`.
  - Для `COMPLETED`: присылается `results` (та же схема, что выше) и `progress=1.0`.
  - Для `FAILED`: присылается `error`.

Мини‑пример клиента (JS):
```js
const ws = new WebSocket(`ws://${location.host}/ws/status/${taskId}`);
ws.onmessage = (ev) => {
  const data = JSON.parse(ev.data);
  // data.status, data.progress, data.eta_seconds, data.results, data.error
};
```

## Модели faster‑whisper

- Поддерживаются стандартные имена моделей Whisper, например: `tiny`, `base`, `small`, `medium`, `large-v3`.
- Указывайте нужную модель в `WHISPER_MODEL` или через UI. Сервис передает это имя в `WhisperModel(model_name, ...)` и скачивает/использует совместимую конверсию CTranslate2 автоматически.
- Выбор `compute_type` влияет на производительность/память:
  - GPU (CUDA 12.x): чаще всего `float16`.
  - CPU: по умолчанию `int8` (наиболее экономично по памяти).

## Быстрый тест (PowerShell)

1) Загрузка файла:
```powershell
curl -F "file=@D:/path/to/audio.mp3" http://localhost:8000/api/v1/upload
```
Скопируйте значение `stored_path` из ответа.

2) Создание задачи:
```powershell
$body = @{ file_path = "D:\Python\whisper_transcribe_api\uploads\audio.mp3" } | ConvertTo-Json
Invoke-RestMethod -Uri "http://localhost:8000/api/v1/create_task" -Method Post -ContentType "application/json" -Body $body
```
Сохраните `task_id`.

3) Опрос статуса:
```powershell
$taskId = "<uuid>"
Invoke-RestMethod -Uri "http://localhost:8000/api/v1/status/$taskId" -Method Get
```
При готовности придут сегменты с таймкодами; в процессе могут приходить `progress` (0..1) и `eta_seconds`.

4) Экспорт результата:
```powershell
Invoke-WebRequest -Uri "http://localhost:8000/export/$taskId.txt" -OutFile result.txt
Invoke-WebRequest -Uri "http://localhost:8000/export/$taskId.srt" -OutFile result.srt
Invoke-WebRequest -Uri "http://localhost:8000/export/$taskId.json" -OutFile result.json
```

## Очередь и статусы

- Очередь: один фон‑воркер обрабатывает по порядку
- Статусы: `PENDING`, `IN_PROGRESS`, `COMPLETED`, `FAILED`
- `queue_position` — 0‑базовый индекс в очереди ожидающих
- Для `IN_PROGRESS` возможны поля `progress` (0..1) и `eta_seconds`

## Интеграция с 1С (локально и серверно)

Поддерживается работа как из локальной файловой базы (толстый/тонкий клиент), так и из клиент‑серверной ИБ.

Эндпоинты backend (по умолчанию): `http://localhost:8000`.
Если backend размещён на другом сервере, укажите `host:port` этого сервера.

Что делает 1С‑форма:
1) Загружает файл на `/api/v1/upload` (multipart) → получает `stored_path`.
2) Создаёт задачу `/api/v1/create_task` с `{ file_path: stored_path }` → получает `task_id`.
3) Раз в 2 секунды опрашивает `/api/v1/status/{task_id}`.
4) При `COMPLETED` заполняет таблицу фраз (`start`, `end`, `text`).

Готовая управляемая форма (вариант «внешняя обработка» или общая форма):
- Элементы: `ПутьКФайлу`, кнопки `Загрузить`, `СоздатьЗадачу`, `СтартОпрос`, `СтопОпрос`, `ОтменаЗадачи`, метки `Статус`, `Очередь`, `Процент`, `ETA`, полоса `Прогресс`, таблица `Фразы` (колонки `Начало`, `Конец`, `Текст`), таймер `Таймер` (2000 мс, выключен по умолчанию).
- Модуль формы содержит HTTP‑вызовы через `HTTPСоединение`/`HTTPЗапрос`.

Локальный режим (файловая ИБ):
- Соединение: `Новый HTTPСоединение("localhost", 8000)`.
- Файлы берутся с диска клиента и отправляются на backend.
- Никаких дополнительных разрешений обычно не требуется (убедитесь, что брандмауэр не блокирует localhost:8000).

Серверный режим (клиент‑серверная ИБ):
- Тот же код формы, но обращение идёт из тонкого клиента.
- Если backend не на `localhost`, используйте внешний адрес, например: `api.myhost.local:8000` или публикацию в IIS с HTTPS.
- Убедитесь, что сеть/фаерволл разрешают исходящие HTTP(S) к адресу backend.
- При публикации в IIS проверьте, что директория статики и маршруты API доступны анонимно.

Мини‑пример кода (универсально):
```1c
Соединение = Новый HTTPСоединение("localhost", 8000);

// Загрузка файла → stored_path
Запрос = Новый HTTPЗапрос("/api/v1/upload");
// Сформируйте multipart вручную или используйте совместимый помощник
// ... (см. полный модуль формы в документации проекта)

// Создание задачи
Запрос = Новый HTTPЗапрос("/api/v1/create_task");
Запрос.Метод = "POST";
Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
Запрос.УстановитьТелоСтрокой(СтрокаВJSON(Новый Структура("file_path", StoredPath)));
Ответ = Соединение.Отправить(Запрос);
TaskID = ПрочитатьJSON(Новый ЧтениеJSON(,(Ответ.ПолучитьТелоКакСтроку()))).task_id;

// Опрос статуса
Ответ = Соединение.Получить("/api/v1/status/" + TaskID);
```

Примечания:
- Кросс‑платформенных ограничений CORS для 1С нет: используются серверные HTTP‑вызовы.
- Если нужен HTTPS с самоподписанным сертификатом, настройте доверие сертификату в ОС.
- При частых больших загрузках рассмотрите публикацию backend в локальной сети (IIS/Reverse‑proxy) и используйте адрес вида `https://api.company.local`.

## Частые проблемы

- Python 3.13 → сборка зависимостей с Rust. Используйте Python 3.11 и новое виртуальное окружение: `py -3.11 -m venv .venv`.
- Нет `ffmpeg` в PATH → установите и проверьте `ffmpeg -version`.
- Ошибка 415 «Неподдерживаемый тип файла» → проверьте расширение (mp3, wav, m4a, flac, ogg).
- Медленная обработка на CPU → используйте короткие записи (до ~5 минут) или подключайте CUDA.
- `Could not locate cudnn_ops64_9.dll` → установите cuDNN 9 и добавьте путь к его `bin` в PATH; на время диагностики выставьте `WHISPER_DEVICE=cpu`.
- Установлен CUDA Toolkit 13.x → ошибка `cublas64_12.dll not found`. Решение: установите параллельно CUDA Toolkit 12.x (напр., 12.4) и поднимите его `bin` выше в PATH, либо запустите на CPU с `WHISPER_DEVICE=cpu`.

## Полная инструкция по интеграции с 1С:Enterprise

Ниже — самодостаточная инструкция для локального и серверного режимов с сохранением всех загруженных файлов и их транскрибаций в 1С.

### 1. Структура объектов 1С

- __Справочник «Аудиофайлы»__
  - Реквизиты:
    - `ИмяФайла` (Строка 250)
    - `ПолныйПутьКлиента` (Строка 500) — путь файла на клиенте (для истории)
    - `StoredPath` (Строка 500) — путь, возвращённый backend `/api/v1/upload`
    - `ДатаЗагрузки` (Дата)
  - Формы: Форма списка и Форма элемента (по умолчанию)

- __Справочник «Транскрибации»__
  - Реквизиты:
    - `Аудиофайл` (СправочникСсылка.Аудиофайлы)
    - `TaskID` (Строка 100)
    - `Статус` (Строка 20) — PENDING/IN_PROGRESS/COMPLETED/FAILED
    - `Прогресс` (Число 5,2)
    - `ETAСек` (Число 10,0)
    - `Ошибка` (Строка 1000)
  - Табличная часть `Фразы`:
    - `Начало` (Число 15,3)
    - `Конец` (Число 15,3)
    - `Текст` (Строка 1000)
  - Формы: Форма списка и Форма элемента (по умолчанию)

Создавать записи в этих справочниках будет модуль формы (см. ниже). Для крупных текстов допускается заменить тип `Текст` на `ХранилищеЗначения` с полем большого текста.

### 2. Форма интеграции (управляемая)

Создайте Общую форму или Внешнюю обработку с управляемой формой. Добавьте элементы:

- Поле ввода `ПутьКФайлу` (Строка)
- Кнопки: `ВыбратьФайл`, `Загрузить`, `СоздатьЗадачу`, `СтартОпрос`, `СтопОпрос`, `ОтменаЗадачи`, `ЭкспортJSON`
- Метки: `Статус`, `Очередь`, `Процент`, `ETA`
- Индикатор `Прогресс` (Шкала/Полоса)
- Табличное поле `Фразы` c колонками: `Начало`, `Конец`, `Текст`
- Таймер `Таймер` (Интервал 2000 мс, по умолчанию Выключен)

Параметры:
- Реквизит формы `АдресAPI` (Строка, по умолчанию `http://localhost:8000`)
- Реквизит формы `СсылкаАудио` (СправочникСсылка.Аудиофайлы)
- Реквизит формы `СсылкаТранск` (СправочникСсылка.Транскрибации)

### 3. Полный модуль формы (пример)

```1c
&НаКлиентеНаСервереБезКонтекста
Функция MIMEПоРасширению(ИмяФайла) Экспорт
    Расш = СтрЗаменить(СтрНРег(ПолучитьРасширениеФайла(ИмяФайла)), ".", "");
    Если Расш = "mp3" Тогда Возврат "audio/mpeg"; КонецЕсли;
    Если Расш = "wav" Тогда Возврат "audio/wav"; КонецЕсли;
    Если Расш = "m4a" Тогда Возврат "audio/mp4"; КонецЕсли;
    Если Расш = "flac" Тогда Возврат "audio/flac"; КонецЕсли;
    Если Расш = "ogg" Тогда Возврат "audio/ogg"; КонецЕсли;
    Возврат "application/octet-stream";
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция РазобратьАдресAPI(Адрес) Экспорт
    ЛокАдрес = СокрЛП(Адрес);
    SSL = Ложь;
    Если СтрНачинаетсяС(СтрНРег(ЛокАдрес), "https://") Тогда
        SSL = Истина;
        ЛокАдрес = Сред(ЛокАдрес, 9);
    ИначеЕсли СтрНачинаетсяС(СтрНРег(ЛокАдрес), "http://") Тогда
        ЛокАдрес = Сред(ЛокАдрес, 8);
    КонецЕсли;
    База = "";
    ПозицияСлэш = Найти(ЛокАдрес, "/");
    Если ПозицияСлэш > 0 Тогда
        База = Сред(ЛокАдрес, ПозицияСлэш);
        ЛокАдрес = Лев(ЛокАдрес, ПозицияСлэш - 1);
    КонецЕсли;
    Хост = ЛокАдрес; Порт = ?(SSL, 443, 80);
    ПозицияДвоет = Найти(ЛокАдрес, ":");
    Если ПозицияДвоет > 0 Тогда
        Хост = Лев(ЛокАдрес, ПозицияДвоет - 1);
        ПортСтр = Сред(ЛокАдрес, ПозицияДвоет + 1);
        Если Не ПустаяСтрока(ПортСтр) Тогда Порт = Число(ПортСтр); КонецЕсли;
    КонецЕсли;
    Возврат Новый Структура("Хост,Порт,SSL,База", Хост, Порт, SSL, База);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьСоединение(АдресAPI) Экспорт
    П = РазобратьАдресAPI(АдресAPI);
    Возврат Новый HTTPСоединение(П.Хост, П.Порт, "", "", П.SSL);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПолныйПуть(АдресAPI, ОтнПуть) Экспорт
    П = РазобратьАдресAPI(АдресAPI);
    База = П.База;
    Если ПустаяСтрока(База) Тогда Возврат ОтнПуть; КонецЕсли;
    Если Не СтрНачинаетсяС(ОтнПуть, "/") Тогда ОтнПуть = "/" + ОтнПуть; КонецЕсли;
    Если Не СтрНачинаетсяС(База, "/") Тогда База = "/" + База; КонецЕсли;
    Возврат База + ОтнПуть;
КонецФункции

&НаКлиенте
Процедура ПриОткрытии(Отказ)
    Если ПустаяСтрока(АдресAPI) Тогда АдресAPI = "http://localhost:8000"; КонецЕсли;
    Статус = ""; Очередь = ""; Процент = 0; ETA = "";
КонецПроцедуры

&НаКлиенте
Процедура ВыбратьФайл(Команда)
    Выбор = Новый ДиалогВыбораФайла();
    Выбор.ПолноеИмяФайла = ПутьКФайлу;
    Выбор.Фильтр = "Аудио (mp3, wav, m4a, flac, ogg)|*.mp3;*.wav;*.m4a;*.flac;*.ogg";
    Если Выбор.Выбрать() Тогда
        ПутьКФайлу = Выбор.ПолноеИмяФайла;
    КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура Загрузить(Команда)
    Если ПустаяСтрока(ПутьКФайлу) Тогда
        Сообщить("Выберите файл"); Возврат;
    КонецЕсли;
    Попытка
        // 1) Создаём запись справочника Аудиофайлы
        Ауд = Справочники.Аудиофайлы.СоздатьЭлемент();
        Ауд.ИмяФайла = ИмяФайла(ПутьКФайлу);
        Ауд.ПолныйПутьКлиента = ПутьКФайлу;
        Ауд.ДатаЗагрузки = ТекущаяДата();
        Ауд.Записать();
        СсылкаАудио = Ауд.Ссылка;

        // 2) multipart upload
        Соед = ПолучитьСоединение(АдресAPI);
        Запрос = Новый HTTPЗапрос(ПолныйПуть(АдресAPI, "/api/v1/upload"));
        Граница = "----1C" + Формат(Новый УникальныйИдентификатор(), "N");
        Запрос.Заголовки.Вставить("Content-Type", "multipart/form-data; boundary=" + Граница);

        Двоич = Новый ДвоичныеДанные(ПутьКФайла);
        Миме = MIMEПоРасширению(ПутьКФайла);

        Поток = Новый ЗаписьДвоичныхДанных;
        // Заголовок части
        Строка = "--" + Граница + Символы.ПС
               + "Content-Disposition: form-data; name=\"file\"; filename=\"" + ИмяФайла(ПутьКФайла) + "\"" + Символы.ПС
               + "Content-Type: " + Миме + Символы.ПС + Символы.ПС;
        Поток.ЗаписатьСтроку(Строка, КодировкаТекста.UTF8);
        // Тело файла
        Поток.Записать(Двоич);
        // Закрывающие границы
        Поток.ЗаписатьСтроку(Символы.ПС + "--" + Граница + "--" + Символы.ПС, КодировкаТекста.UTF8);

        Данные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
        Запрос.УстановитьТелоИзДвоичныхДанных(Данные);

        Ответ = Соед.Отправить(Запрос);
        Если Ответ.КодСостояния <> 200 Тогда
            ВызватьИсключение "Ошибка загрузки: " + Ответ.КодСостояния;
        КонецЕсли;
        ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
        Чт = Новый ЧтениеJSON;
        Чт.УстановитьСтроку(ТекстОтвета);
        Объект = ПрочитатьJSON(Чт);
        Ауд = СсылкаАудио.ПолучитьОбъект();
        Ауд.StoredPath = Объект.stored_path;
        Ауд.Записать();
        Сообщить("Загружено. StoredPath сохранён в 1С.");
    Исключение
        Сообщить(ОписаниеОшибки());
    КонецПопытки;
КонецПроцедуры

&НаКлиенте
Процедура СоздатьЗадачу(Команда)
    Если Не ЗначениеЗаполнено(СсылкаАудио) Тогда
        Сообщить("Сначала загрузите файл"); Возврат;
    КонецЕсли;
    Ауд = СсылкаАудио.ПолучитьОбъект();
    Если ПустаяСтрока(Ауд.StoredPath) Тогда
        Сообщить("Нет StoredPath у файла"); Возврат;
    КонецЕсли;
    Попытка
        Соед = ПолучитьСоединение(АдресAPI);
        Запрос = Новый HTTPЗапрос(ПолныйПуть(АдресAPI, "/api/v1/create_task"));
        Запрос.Метод = "POST";
        Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
        Тело = СтрокаВJSON(Новый Структура("file_path", Ауд.StoredPath));
        Запрос.УстановитьТелоСтрокой(Тело, КодировкаТекста.UTF8);
        Ответ = Соед.Отправить(Запрос);
        Если Ответ.КодСостояния <> 200 Тогда
            ВызватьИсключение "Ошибка create_task: " + Ответ.КодСостояния;
        КонецЕсли;
        Чт = Новый ЧтениеJSON; Чт.УстановитьСтроку(Ответ.ПолучитьТелоКакСтроку()); R = ПрочитатьJSON(Чт);

        Тр = Справочники.Транскрибации.СоздатьЭлемент();
        Тр.Аудиофайл = СсылкаАудио;
        Тр.TaskID = R.task_id;
        Тр.Статус = R.status;
        Тр.Записать();
        СсылкаТранск = Тр.Ссылка;
        Статус = Тр.Статус;
        Очередь = ?(ЗначениеЗаполнено(R.queue_position), Формат(R.queue_position, "ЧГ=0"), "");
        // включаем таймер опроса
        ЭлементыФормы.Таймер.Видимость = Истина; ЭлементыФормы.Таймер.Включить();
    Исключение
        Сообщить(ОписаниеОшибки());
    КонецПопытки;
КонецПроцедуры

&НаКлиенте
Процедура Таймер(Элемент)
    Если Не ЗначениеЗаполнено(СсылкаТранск) Тогда Возврат; КонецЕсли;
    Тр = СсылкаТранск.ПолучитьОбъект();
    Адрес = ПолныйПуть(АдресAPI, "/api/v1/status/" + Тр.TaskID);
    Попытка
        Соед = ПолучитьСоединение(АдресAPI);
        Ответ = Соед.Получить(Адрес);
        Если Ответ.КодСостояния <> 200 Тогда
            Сообщить("Ошибка status: " + Ответ.КодСостояния); Возврат;
        КонецЕсли;
        Чт = Новый ЧтениеJSON; Чт.УстановитьСтроку(Ответ.ПолучитьТелоКакСтроку()); S = ПрочитатьJSON(Чт);
        // обновим объект в 1С
        Тр.Статус = S.status;
        Если ТипЗнч(S.progress) <> Тип("Неопределено") Тогда Тр.Прогресс = S.progress * 100; КонецЕсли;
        Если ТипЗнч(S.eta_seconds) <> Тип("Неопределено") Тогда Тр.ETAСек = S.eta_seconds; КонецЕсли;
        Если ТипЗнч(S.error) <> Тип("Неопределено") Тогда Тр.Ошибка = S.error; КонецЕсли;
        Тр.Записать();
        // обновим форму
        Статус = Тр.Статус; Процент = Тр.Прогресс; ETA = ?(ЗначениеЗаполнено(Тр.ETAСек), Формат(Тр.ETAСек, "ЧГ=0"), "");

        Если S.status = "COMPLETED" Тогда
            // загрузим json результата и заполним табличную часть
            URLРез = ПолныйПуть(АдресAPI, "/export/" + Тр.TaskID + ".json");
            Ответ2 = Соед.Получить(URLРез);
            Если Ответ2.КодСостояния = 200 Тогда
                Чт2 = Новый ЧтениеJSON; Чт2.УстановитьСтроку(Ответ2.ПолучитьТелоКакСтроку());
                R = ПрочитатьJSON(Чт2);
                // очистим и заполним ТЧ
                Тр.Фразы.Очистить();
                Для Каждого P Из R.phrases Цикл
                    Нов = Тр.Фразы.Добавить();
                    Нов.Начало = P.start; Нов.Конец = P.end; Нов.Текст = P.text;
                КонецЦикла;
                Тр.Записать();
                // отобразим в форме
                Фразы = Неопределено; // привязать к источнику данных формы, если используется
            КонецЕсли;
            ЭлементыФормы.Таймер.Выключить();
        ИначеЕсли S.status = "FAILED" Тогда
            ЭлементыФормы.Таймер.Выключить();
        КонецЕсли;
    Исключение
        // Не прерываем таймер на сетевых огрехах, просто показываем сообщение
        Сообщить(ОписаниеОшибки());
    КонецПопытки;
КонецПроцедуры

&НаКлиенте
Процедура СтартОпрос(Команда)
    Если ЭлементыФормы.Таймер.Включен Тогда Возврат; КонецЕсли;
    ЭлементыФормы.Таймер.Включить();
КонецПроцедуры

&НаКлиенте
Процедура СтопОпрос(Команда)
    Если ЭлементыФормы.Таймер.Включен Тогда ЭлементыФормы.Таймер.Выключить(); КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ОтменаЗадачи(Команда)
    Если Не ЗначениеЗаполнено(СсылкаТранск) Тогда Возврат; КонецЕсли;
    Тр = СсылкаТранск.ПолучитьОбъект();
    Попытка
        Соед = ПолучитьСоединение(АдресAPI);
        Запрос = Новый HTTPЗапрос(ПолныйПуть(АдресAPI, "/api/v1/cancel/" + Тр.TaskID));
        Запрос.Метод = "POST";
        Ответ = Соед.Отправить(Запрос);
        Если Ответ.КодСостояния = 200 Тогда
            Сообщить("Отменено"); ЭлементыФормы.Таймер.Выключить();
        Иначе
            Сообщить("Не удалось отменить: " + Ответ.КодСостояния);
        КонецЕсли;
    Исключение
        Сообщить(ОписаниеОшибки());
    КонецПопытки;
КонецПроцедуры

&НаКлиенте
Процедура ЭкспортJSON(Команда)
    Если Не ЗначениеЗаполнено(СсылкаТранск) Тогда Возврат; КонецЕсли;
    Тр = СсылкаТранск.ПолучитьОбъект();
    Соед = ПолучитьСоединение(АдресAPI);
    Ответ = Соед.Получить(ПолныйПуть(АдресAPI, "/export/" + Тр.TaskID + ".json"));
    Если Ответ.КодСостояния = 200 Тогда
        Файл = ПолучитьИмяВременногоФайла("json");
        ЗаписатьТекст(Файл, Ответ.ПолучитьТелоКакСтроку(), КодировкаТекста.UTF8);
        ОткрытьВнешнееПриложение(Файл);
    КонецЕсли;
КонецПроцедуры
```

Примечания по коду:
- Используется ручная сборка multipart. Работает на 8.3.20+ без дополнительных библиотек.
- Сохранение: загруженный файл — в `Справочник.Аудиофайлы`, задачи и фразы — в `Справочник.Транскрибации`.
- Для привязки табличного поля формы к ТЧ создайте реквизит формы (ИсточникДанных = Объект `СсылкаТранск.ПолучитьОбъект()`), либо программно устанавливайте набор.

### 4. Локальный vs Серверный режим

- Локально: `АдресAPI = http://localhost:8000`.
- Сервер: укажите внешний адрес backend, например `https://api.company.local`. Проверьте доступность из тонкого клиента и разрешения фаервола.
- HTTPS с самоподписанным сертификатом: добавьте сертификат в доверенные на клиентских ОС.

### 5. Права и безопасность

- Разрешите исходящие HTTP(S) для клиента 1С.
- Если backend требует авторизацию, добавьте заголовок `Authorization` (Bearer/Basic) в запросы `HTTPЗапрос.Заголовки`.
